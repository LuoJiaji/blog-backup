---
title: 'Q-Learing,Sarsa和Sarsa-lambda'
date: 2017-05-07 18:47:16
comments: false
tags:
- RL
---
最近看了一些关于强化学习(Reinforcement Learning)的资料，今天来总结一下RL中一些基本的算法。
<!--more-->
强化学习 (Reinforcement Learning) 是一个机器学习领域中的一个分支, 由于近些年来的技术突破, 和深度学习 (Deep Learning) 的整合, 使得强化学习有了进一步的运用。比如让计算机学着玩游戏, AlphaGo 挑战世界围棋高手, 都是强化学习在行的事。

第一个是**Q-Learning**
先看一下算法的学习过程：
![Q-Learning算法更新过程](http://onaxllwtn.bkt.clouddn.com/2017-05-07-1.png)
Q-Learning在每一次循环中会计算当前的状态和要采取的动作与下一步的状态中所有动作最大值的差，如果这个误差为零，那么算法不会对状态进行更新，如果这个误差不为零(一般情况下正值代表奖励，负值代表惩罚)，则会将这个误差乘以一个固定的学习效率跟新到上一次的状态中去。
算法的学习过程一般会从最靠近奖励或者惩罚的地方开始，因为这些奖励和惩罚是算法跟新的依据。每次迭代过程，算法都会讲这个奖励或者惩罚向前传递，直到传递到第一步，这样算法就算是学会了相应规则下的整个动作。如果想让算法在学习到的经验的基础上探索未知，可以在动作选择的部分加上一个在相对较小的概率下随机选择动作的过程，这样就可以让算法在已有经验的基础上继续探索新的动作。
Q-Learning是一种off-policy的跟新过程，因为算法的跟新部分跟动作选择部分是相对独立的两个部分(虽然都是取Q表中相应的最大值，但是这两部分的计算是独立进行的，互相并不影响)。


第二个是**Sarsa**(state-action-reward-state\_-action\_)
Sarsa中，state和action代表当前的状态和要采取的而动作，state\_和action\_代表的是下一次的状态的要采取的动作。
算法的更新过程如下图：
![Sarsa算法的更新过程](http://onaxllwtn.bkt.clouddn.com/2017-05-07-2.png)
相较于Q-learing来说Sarsa的跟新过程和就是算法下一个状态所采取的动作，因此Sarsa是一种on-policy的更新方法。
相较于Q-Learning来说，Sarsa更加谨慎小心，他会严格安装学习的过程来采取行动，但同时这样也会降低算法探索未知路径的能力，应该说两个算法的性格不相同，Q-Learning更加冒险，勇于探索未知。而Sarsa则更加保守，尽量按照已有的经验来采取行动。


最后一个是**Sarsa-Lambda**
算法的学习过程如下图：
![Sarsa\-Lambda算法的更新过程](http://onaxllwtn.bkt.clouddn.com/2017-05-07-3.png)
Q-Learning和Sarsa每一次只能向前跟新一步，而Sarsa-lambda则可以在一次更新中对多步进行跟新，在Sarsa-Lambda中除了有Q表来存储状态之外，还有一个E表，这个表格会记录算法在获得奖励之前的每一步，当计算的误差值不为零的时候，算法会将之前的每一步乘以相应的系数一起跟新在Q表中。Lambda这个参数可以改变算法跟新过程中每一步对应的权重，当Lambda为0时，算法就是Sarsa算法，当Lambda为1时，算法所走过的每一步的权重都相同，当Lambda的权重为0~1之间时，越接近奖励或惩罚的步权重越大，跟新的幅度也会越大，而距离奖励或惩罚较远的步则权重相对较小，更新的幅度也会比较小。

参考资料：
* [强化学习入门 第四讲 时间差分法（TD方法）](https://zhuanlan.zhihu.com/p/25913410)